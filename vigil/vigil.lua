-----------------------------------------------------------------------------------------
-- vigil.lua
-- a vigil is a type of promise that you keep over and over
-----------------------------------------------------------------------------------------
local exports = {}
exports.__index = exports
local P = {} -- privates

-----------------------------------------------------------------------------------------
-- debug ish
--local vb = _.noop
local vb = print

local idtbl = idtbl or _.noop
local s = s or _.safe

local function pr(val)
    if val == nil then return s(val).red end
    if type(val) == "table" then return idtbl(val) end
    if type(val) == "string" then return val.blue end
    return s(val).yellow
end

-- todo: 
    -- make this feel lua-native
    -- modify implementation to be multiply callable

-----------------------------------------------------------------------------------------
function P.trivial(succeed)
    succeed(true)
end

-----------------------------------------------------------------------------------------
function exports.new(fn)
    local out = {
        fn = fn,
        err = false,
        inputs = 0, -- number of times we have processed a resolve from a parent
        outputs = 0, -- number of times we have processed a resolve from a child
    }

    vb("new promise ",idtbl(out))

    setmetatable(out, exports)
    P.waitForResolve(out, fn, exports.resolve, exports.reject)

    return out
end

-----------------------------------------------------------------------------------------
function P.fulfill(self, result)
    self.value = result
    vb(idtbl(self), ".value is now ", pr(result))
    self.err = false
    P.callHandlers(self)
end

-----------------------------------------------------------------------------------------
function exports.reject(self, error)
    self.err = error
    P.callHandlers(self)
    if not self.handlers then P.rethrow(error) end
end

-----------------------------------------------------------------------------------------
function P.callHandlers(self)
    vb("\t", idtbl(self), " inputs/outputs: ", s(self.inputs).yellow, s(self.outputs).green)

    if not self.handlers then vb(idtbl(self), " there are no handlers"); return end

    local action, param
    if self.err then
        param, action = self.err, "onRejected"
    else
        param, action = self.value, "onFulfilled"
    end

    vb("\t", idtbl(self), "calling all handlers with action ", action.blue,
        " and param ", pr(param)) -- that's right meatwad
   
    for k,v in ipairs(self.handlers) do
        vb("\t\t here's one now ", s(v), s(v[action]))
        _.safe(v[action])(param)
    end
end

-----------------------------------------------------------------------------------------
function P.handle(self, handler)
    vb(idtbl(self), "handle")
    self.handlers = _.append(self.handlers, handler)
 
    vb("\t", idtbl(self), " inputs/outputs: ", s(self.inputs).yellow, s(self.outputs).green)
    if self.outputs == 0 then return end
    
    local func = _.ift(self.err, handler.onRejected, handler.onFulfilled)
    _.safeToCall(func)(self.value)
end

-----------------------------------------------------------------------------------------
function P.rethrow(err)
    assert(false, err)
end

-----------------------------------------------------------------------------------------
function P.waitForResolve(self, fn, onFulfilled, onRejected)
    vb(idtbl(self), "waitForResolve")
    local done = false

    local reject = function(reason)
        vb(idtbl(self), " calling waitForResolve reject")
        if done then vb(idtbl(self), " was already done"); return end
        done = true
        exports.reject(self, reason)
        vb(idtbl(self), " waitForResolve calling onRejected")
        print(idtbl(self), " onRejected is ", s(onRejected))
        _.safe(onRejected)(self, reason) 
    end

    local status, err = pcall( function()
        vb(idtbl(self), "invoking fn: ", s(fn))

        fn( function(value)
            self.inputs = self.inputs + 1
            vb(idtbl(self), "called handler generated by waitForResolve, inputs: ",
                s(self.inputs).yellow)

            if done then vb(idtbl(self), " was already done"); return end
            done = true
            vb(idtbl(self), " onFulfilled from waitForResolve ", pr(value));
            _.safe(onFulfilled)(self, value)
        end, reject)
    end)

    if err then
        reject(err)
    end
end

-----------------------------------------------------------------------------------------
function P.done(self, onFulfilled, onRejected)
    vb(idtbl(self), "done")
    P.handle(self, {
        onFulfilled = onFulfilled,
        onRejected = onRejected or P.rethrow
    })
end

-----------------------------------------------------------------------------------------
function P.isVigil(x)
    return getmetatable(x) == exports
end

-----------------------------------------------------------------------------------------
function P.getUntoThis(value)
    if _.isTable(value) then
        return value.andUntoThis
    end
end

-----------------------------------------------------------------------------------------
function exports:resolve(result)
    result = result or P.trivial

    if not self then
        local newPromise = exports.new(result)
        return newPromise -- avoid tail calls, they shred callstacks
    end

    vb("resolving ", idtbl(self), " with ", pr(result))--, debug.traceback())
    local status, err = pcall( function()
        -- resolve accepts either a promise or a plain value and if
        -- it's a promise, waits for it to complete
        -- going to need some kind of "once"
        if P.isVigil(result) then
            P.handle(result, {
                onFulfilled = function(val)
                    vb(idtbl(self), " calling deferred onFulfilled with ", pr(val))
                    self:resolve(val)
                end,
                onRejected = function(err)
                    self:reject(err)
                end
            })
            return
        end

        self.outputs = self.outputs + 1
        vb(idtbl(self), " calling P.fulfill with ", pr(result))
        P.fulfill(self, result);
    end)

    if err then
        self:reject(err)
    end

    return self
end

-----------------------------------------------------------------------------------------
-- this may seem like a weird name, but of course, in lua `then` is a protected keyword
-- for that reason, I decided to abandon the A+ spec in this regard. No one else is going
-- to make a library with andUntoThis, so we're just gonna go in
-----------------------------------------------------------------------------------------
function exports:andUntoThis(onFulfilled, onRejected)
    vb(idtbl(self), " and unto this")
    local child = exports.new( function(resolve, reject)
        P.done(self, function (result)
            vb("\tandUntoThis done, result is: ", pr(result))
            local out

            if _.isFunction(onFulfilled) then
                vb("\tonFulfilled is a function")
                local status, err = pcall( function()
                    vb("\tcalling resolve with onFulfilled(", pr(result), ")")
                    out = resolve(onFulfilled(result));
                end)

                if err then vb("\trejecting with err"); out = reject(err) end
            else
                vb("\tonFulfilled is no function. result:", pr(result));
                out = resolve(result);
            end
            return out
        end,
        function (error)
            vb("there's an error")
            if _.isFunction(onRejected) then
                vb("\tonRejected is a function")
                local out
                local status, err = pcall( function()
                    vb("\tcalling resolve with onRejected(result))")
                    out = resolve(onRejected(result));
                end)

                if err then vb("\trejecting with err"); out = reject(err) end
                return out
            else
                vb("\tonRejected is no function. result:", tostring(result));
                local out = reject(error)
                return out
            end
        end)
    end)
    return child
end

-----------------------------------------------------------------------------------------
function exports:each(ps)

end

-----------------------------------------------------------------------------------------
return exports
